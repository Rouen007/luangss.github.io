#中断下半部的处理

中断处理程序不在进程上下文中运行，所以不能阻塞。
下半部的任务是执行与中断处理密切相关但中断处理程序本身不执行的工作。


在前一章也提到过，之所以中断会分成上下两部分，是由于中断对时限的要求非常高，需要尽快响应硬件。

##中断下半部处理

那么对于一个中断，如何划分上下两部分呢？哪些处理放在上半部，哪些处理放在下半部？

这里有一些经验可供借鉴：

1. 如果一个任务对时间十分敏感，将其放在上半部
2. 如果一个任务和硬件有关，将其放在上半部
3. 如果一个任务要保证不被其他中断打断，将其放在上半部
4. 其他所有任务，考虑放在下半部

##实现中断下半部的机制

实现下半部的方法很多，随着内核的发展，产生了一些新的方法，也淘汰了一些旧方法。

目前使用最多的是以下3中方法

1. 软中断
2. tasklet
3. 工作队列

软中断是一组静态定义的下半部分接口，有32个，可以在所有处理器上同时执行--即使两个类型相同。
tasklet是一种基于软中断实现的灵活性强，动态创建的下半部实现机制。两个不同类型的tasklet可以在不同处理器上同时执行，但类型相同的tasklet不能同时执行（大部分下半部利用tasklet，像网络这样对性能要求比较高的情况才需要使用软中断）。软中断还必须在编译期间进行静态注册，tasklet可以通过代码进行动态注册。

##软中断
一个软中断不会抢占另一个软中断，唯一可以抢占软中断的是中断处理程序。
软中断处理程序执行的时候，允许相应中断，但它自己不能休眠。
![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/8.1.PNG)

1. 分配索引
2. 注册处理程序
3. 触发软中断

##tasklet
tasklet也是利用软中断来实现的，但是它提供了比软中断更好用的接口(其实就是基于软中断又封装了一下)，

所以除了对性能要求特别高的情况，一般建议使用tasklet来实现自己的中断。


tasklet对应的结构体在 <linux/interrupt.h> 中

struct tasklet_struct
{
    struct tasklet_struct \*next; /\* 链表中的下一个tasklet \*/
    unsigned long state;         /\* tasklet状态 \*/
    atomic_t count;              /\* 引用计数器 \*/
    void (*func)(unsigned long); /\* tasklet处理函数 \*/
    unsigned long data;          /\* tasklet处理函数的参数 \*/
};
tasklet状态state只有3种值：

值 0 表示该tasklet没有被调度
值 TASKLET_STATE_SCHED 表示该tasklet已经被调度
值 TASKLET_STATE_RUN 表示该tasklet已经运行
引用计数器count 的值不为0，表示该tasklet被禁止。

 
在设计软中断的时候：最终在内核中实现的方案是：不会立即处理重新触发的软中断，作为改进，当大量软中断出现的时候，内核会唤醒一组内核进程来处理这些负载。这些线程在最低的优先级上运行，避免跟重要任务抢占资源。






