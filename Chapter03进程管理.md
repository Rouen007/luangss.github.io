#进程管理

##进程
进程：处于执行期的程序。（进程不限于一段可执行的代码，还包括其他资源：打开文件，挂起信号，内核的内部数据，处理器状态，一个或多个具有内存映射的内存空间，一个或多个执行线程，存放全局变量的数据段等）

（执行）线程：在进程中活动的对象。每个线程有一个独立的程序计数器、进程栈、一组进程寄存器.

内核调度的对象是线程不是进程.

对Linux而言，线程只是一种特殊的进程.

现代操作系统中，进程提供两种虚拟机制：虚拟处理器、虚拟内存。

同一进程中的线程之间可以共享虚拟内存但是都拥有自己的虚拟处理器。（每个进程有独立的虚拟处理器和虚拟内存，每个线程有独立的虚拟处理器，同一个进程内的线程有可能会共享虚拟内存。）

内核把进程的列表存放在叫任务队列（task list）的双向循环列表中

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/3.1.PNG)

进程描述符中包含一个具体进程所需的所有信息（它打开的文件，进程的地址，挂起的信号，进程的状态等）

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/3.2.PNG)

进程标识PID和线程标识TID对于同一个进程或线程来说都是相等的。

##进程状态
运行、可中断、不可中断、被其他进程跟踪、停止

运行（TASK_RUNNING）：进程是可执行的：正在执行、在队列中等待执行。
可中断（TASK_INTERRUPTIBLE）：进程正在睡眠（阻塞），等待某些条件。
不可中断（TASK_UNITERRUPTIBLE）
被其他进程跟踪（__TASK_TRACED）
停止（__TASK_STOPPED）

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/3.3.png)


一个程序通过执行系统调用、触发异常陷入内核空间----内核代表进程执行，并处于**进程上下文中**。

每个进程都有父进程（parent ptr），若干子进程（children ptr list）

## 进程创建
Linux中创建进程与其他系统有个主要区别，Linux中创建进程分2步：fork()和exec()。

fork: 通过拷贝当前进程创建一个子进程。子进程与父进程的区别在于：PID、PPID和某些资源和统计量（挂起的信号）
Linux中fork()采用写时拷贝，内核不需要复制整个进程地址空间，而是让父子共享同一拷贝，只有在写入数据的时候，才复制数据。
fork的开销往往在于复制父进程的页表以及为子进程创建唯一的进程描述符。(由于fork执行之后往往立即调用exec，避免了复制大量不需要的数据)
创建的流程：

1. 调用dup_task_struct()为新进程分配内核栈，thread_info，task_struct等，其中的内容与父进程相同。
2. check新进程(进程数目是否超出上限等)
3. 清理新进程的信息(比如PID置0等)，使之与父进程区别开。task_struct中大多数数据未修改。
4. 新进程状态置为 TASK_UNINTERRUPTIBLE，不会投入运行。
5. 更新task_struct的flags成员。
6. 调用alloc_pid()为新进程分配一个有效的PID。
7. 根据clone()的参数标志，拷贝或共享相应的信息。
8. 做一些扫尾工作并返回子进程指针。

exec: 读取可执行文件，将其载入到内存（地址空间）中运行。

创建进程的fork()函数实际上最终是调用clone()函数。

创建线程和进程的步骤一样，只是最终传给clone()函数的参数不同。
比如，通过一个普通的fork来创建进程，相当于：clone(SIGCHLD, 0)
创建一个和父进程共享地址空间，文件系统资源，文件描述符和信号处理程序的进程，即一个线程：clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)

在内核中创建的内核线程与普通的进程之间还有个主要区别在于：内核线程没有独立的地址空间，它们只能在内核空间运行（从不切换到用户空间）。（与之前提到的Linux内核是个单内核有关）
可以被调度，可以被抢占。

##进程的终结
一个进程的终结需要释放所占有的资源并通知父进程。

1. 设置task_struct中的标识成员设置为PF_EXITING
2. 调用del_timer_sync()删除内核定时器, 确保没有定时器在排队和运行
3. 调用exit_mm()释放进程占用的mm_struct
4. 调用sem__exit()，使进程离开等待IPC（进程间通信）信号的队列
5. 调用exit_files()和exit_fs()，释放进程占用的文件描述符和文件系统资源
6. 把task_struct的exit_code设置为进程的返回值
7. 调用exit_notify()向父进程发送信号，重新找养父，并把自己的状态设为EXIT_ZOMBIE
8. 切换到新进程继续执行

子进程进入EXIT_ZOMBIE之后，虽然永远不会被调度，关联的资源也释放掉了，但是它本身占用的内存还没有释放，
比如创建时分配的内核栈，task_struct结构等。这些由父进程来释放。父进程上的操作(release_task)
父进程受到子进程发送的exit_notify()信号后，将该子进程的进程描述符和所有进程独享的资源全部删除。

从上面的步骤可以看出，必须要确保每个子进程都有父进程，如果父进程在子进程结束之前就已经结束了会怎么样呢？

子进程在调用exit_notify()时已经考虑到了这点。
如果子进程的父进程已经退出了，那么子进程在退出时，exit_notify()函数会先调用forget_original_parent()，然后再调用find_new_reaper()来寻找新的父进程。
find_new_reaper()函数先在当前线程组中找一个线程作为父亲，如果找不到，就让init做父进程。(init进程是在linux启动时就一直存在的)