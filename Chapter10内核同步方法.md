内核中提供了多种方法来防止竞争条件，理解了这些方法的使用场景有助于我们在编写内核代码时选用合适的同步方法，

从而即可保证代码中临界区的安全，同时也让性能的损失降到最低。

主要内容：

1. 原子操作
2. 自旋锁
3. 读-写自旋锁
4. 信号量
5. 读写信号量
6. 互斥体
7. 完成变量
8. 大内核锁
9. 顺序锁
10. 禁止抢占
11. 顺序和屏障

##原子操作

原子操作是由编译器来保证的，保证一个线程对数据的操作不会被其他线程打断。

原子操作有2类：

1. 原子整数操作，有32位和64位。头文件分别为<asm/atomic.h>和<asm/atomic64.h>
2. 原子位操作。头文件 <asm/bitops.h>
 

原子操作的api很简单，参见相应的头文件即可。
原子操作头文件与具体的体系结构有关，比如x86架构的相关头文件在 arch/x86/include/asm/*.h
一个字长的读取总是原子地发生，绝不可能对同一个字交错地进行读写。

##自旋锁

原子操作只能用于临界区只有一个变量的情况，实际应用中，临界区的情况要复杂的多。

对于复杂的临界区，linux内核中也提供了多种同步方法，自旋锁就是其中一种。

**自旋锁最多只能被一个可执行线程持有**
自旋锁的特点就是当一个线程获取了锁之后，其他试图获取这个锁的线程一直在循环等待获取这个锁，直至锁重新可用。

由于线程实在一直循环的获取这个锁，所以会造成CPU处理时间的浪费，因此最好将自旋锁用于能很快处理完的临界区。
一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋。
持有自旋锁的时间最好小于完成零次上下文切换耗时。

自旋锁的实现与体系结构有关，所以相应的头文件 <asm/spinlock.h> 位于相关体系结构的代码中。

自旋锁使用时有2点需要注意：

1. 自旋锁是不可递归的，递归的请求同一个自旋锁会自己锁死自己。
2. 线程获取自旋锁之前，要禁止当前处理器上的中断。（防止获取锁的线程和中断形成竞争条件） 比如：当前线程获取自旋锁后，在临界区中被中断处理程序打断，中断处理程序正好也要获取这个锁， 于是中断处理程序会等待当前线程释放锁，而当前线程也在等待中断执行完后再执行临界区和释放锁的代码。

中断处理下半部的操作中使用自旋锁尤其需要小心：

1. 下半部处理和进程上下文共享数据时，由于下半部的处理可以抢占进程上下文的代码， 所以进程上下文在对共享数据加锁前要禁止下半部的执行，解锁时再允许下半部的执行。
2. 中断处理程序（上半部）和下半部处理共享数据时，由于中断处理（上半部）可以抢占下半部的执行， 所以下半部在对共享数据加锁前要禁止中断处理（上半部），解锁时再允许中断的执行。
3. 同一种tasklet不能同时运行，所以同类tasklet中的共享数据不需要保护。
4. 不同类tasklet中共享数据时，其中一个tasklet获得锁后，(就需要在访问下半部中的数据前先获得一个普通的自旋锁)，不用禁止其他tasklet的执行，因为同一个处理器上不会有tasklet相互抢占的情况
5. 同类型或者非同类型的软中断在共享数据时，必须得到锁的保护，也不用禁止下半部，因为同一个处理器上不会有软中断互相抢占的情况

需要关闭的只是当前处理器上的中断。如果中断发生在不同的处理器上，即使中断处理程序在同一锁上自旋，也不会妨碍锁的持有者最终释放锁。
自旋锁方法列表如下：

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/10.1.PNG)

##读-写自旋锁

写操作时完全互斥，只要没有写，多个并发的读是安全的。

1. 读写自旋锁除了和普通自旋锁一样有自旋特性以外，还有以下特点： 
读锁之间是共享的 ，即一个线程持有了读锁之后，其他线程也可以以读的方式持有这个锁
2. 写锁之间是互斥的 
即一个线程持有了写锁之后，其他线程不能以读或者写的方式持有这个锁
3. 读写锁之间是互斥的 
即一个线程持有了读锁之后，其他线程不能以写的方式持有这个锁

**注：读写锁要分别使用，不能混合使用，否则会造成死锁。**

DEFINE_RWLOCK(mr_rwlock);

read_lock(&mr_rwlock);
/\* 临界区(只读).... \*/
read_unlock(&mr_rwlock);

write_lock(&mr_lock);
/\* 临界区(读写)... \*/
write_unlock(&mr_lock);

读写锁的相关函数如下：

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/10.2.PNG)

##信号量
信号量也是一种锁，和自旋锁不同的是，线程获取不到信号量的时候，不会像自旋锁一样循环的去试图获取锁，
而是进入睡眠，直至有信号量释放出来时，才会唤醒睡眠的线程，进入临界区执行。是一种睡眠锁。

由于使用信号量时，线程会睡眠，所以等待的过程不会占用CPU时间。所以信号量适用于等待时间较长的临界区。
信号量消耗的CPU时间的地方在于使线程睡眠和唤醒线程，
如果 （使线程睡眠 + 唤醒线程）的CPU时间 > 线程自旋等待的CPU时间，那么可以考虑使用自旋锁。

信号量有二值信号量和计数信号量2种，其中二值信号量比较常用。
二值信号量表示信号量只有2个值，即0和1。信号量为1时，表示临界区可用，信号量为0时，表示临界区不可访问。
二值信号量表面看和自旋锁很相似，区别在于争用自旋锁的线程会一直循环尝试获取自旋锁，
而争用信号量的线程在信号量为0时，会进入睡眠，信号量可用时再被唤醒。

计数信号量有个计数值，比如计数值为5，表示同时可以有5个线程访问临界区。

由于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号锁，因为在中断上下文中是不能进行调度的，信号量不同于自旋锁，他不会禁止内核抢占，所以持有信号量的代码可以被抢占。


信号量相关函数参照: <linux/semaphore.h> 实现方法参照：kernel/semaphore.c
/\* 定义并声明一个信号量，名字为mr_sem，用于信号量计数 */
static DECLARE_MUTEX(mr_sem);

/\* 试图获取信号量....， 信号未获取成功时，进入睡眠
 \* 此时，线程状态为 TASK_INTERRUPTIBLE
 \*/
down_interruptible(&mr_sem);
/\* 这里也可以用：
 \* down(&mr_sem);
 \* 这个方法把线程状态置为 TASK_UNINTERRUPTIBLE 后睡眠
 \*/

/\* 临界区 ... \*/

/\* 释放给定的信号量 \*/
up(&mr_sem);

一般用的比较多的是down_interruptible()方法，因为以 TASK_UNINTERRUPTIBLE 方式睡眠无法被信号唤醒。

对于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 补充说明一下：

TASK_INTERRUPTIBLE - 可打断睡眠，可以接受信号并被唤醒，也可以在等待条件全部达成后被显式唤醒(比如wake_up()函数)。
TASK_UNINTERRUPTIBLE - 不可打断睡眠，只能在等待条件全部达成后被显式唤醒(比如wake_up()函数)。

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/10.3.PNG)

/\* Please don't access any members of this structure directly \*/
struct semaphore {
    spinlock_t        lock;
    unsigned int        count;
    struct list_head    wait_list;
};
可以发现信号量结构体中有个自旋锁，这个自旋锁的作用是保证信号量的down和up等操作不会被中断处理程序打断。

##读写信号量

读写信号量和信号量之间的关系 与 读写自旋锁和普通自旋锁之间的关系 差不多。
读写信号量都是二值信号量，即计数值最大为1，增加读者时，计数器不变，增加写者，计数器才减一。
也就是说读写信号量保护的临界区，最多只有一个写者，但可以有多个读者。

读写信号量的相关内容参见：<asm/rwsem.h> 具体实现与硬件体系结构有关。

##互斥体

互斥体也是一种可以睡眠的锁，相当于二值信号量，只是提供的API更加简单，使用的场景也更严格一些，如下所示：

1. mutex的计数值只能为1，也就是最多只允许一个线程访问临界区
2. 在同一个上下文中上锁和解锁
3. 不能递归的上锁和解锁
4. 持有个mutex时，进程不能退出
5. mutex不能在中断或者下半部中使用，也就是mutex只能在进程上下文中使用
6. mutex只能通过官方API来管理，不能自己写代码操作它

在面对互斥体和信号量的选择时，只要满足互斥体的使用场景就尽量优先使用互斥体。

在面对互斥体和自旋锁的选择时，参见下表：

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/10.4.PNG)

互斥体头文件：<linux/mutex.h>
常用的互斥体方法如下：

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/10.5.PNG)

##完成变量

完成变量的机制类似于信号量，

比如一个线程A进入临界区之后，另一个线程B会在完成变量上等待，线程A完成了任务出了临界区之后，使用完成变量来唤醒线程B。

完成变量的头文件：<linux/completion.h>

完成变量的API也很简单：
![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/10.6.PNG)

##大内核锁

大内核锁已经不再使用，只存在与一些遗留的代码中。
一种递归锁，与自旋锁不同，不能在中断上下文中申请，在持有时间禁止内核被抢占。

##顺序锁
顺序锁为读写共享数据提供了一种简单的实现机制。

之前提到的读写自旋锁和读写信号量，在读锁被获取之后，写锁是不能再被获取的，
也就是说，必须等所有的读锁释放后，才能对临界区进行写入操作。

顺序锁则与之不同，读锁被获取的情况下，写锁仍然可以被获取。

使用顺序锁的读操作在读之前和读之后都会检查顺序锁的序列值，如果前后值不符，则说明在读的过程中有写的操作发生，
那么读操作会重新执行一次，直至读前后的序列值是一样的。

do
{
    /\* 读之前获取 顺序锁foo 的序列值 \*/
    seq = read_seqbegin(&foo);
...
} while(read_seqretry(&foo, seq)); /\* 顺序锁foo此时的序列值!=seq 时返回true，反之返回false \*/

顺序锁优先保证写锁的可用，所以适用于那些读者很多，写者很少，且写优于读的场景。

顺序锁的使用例子可以参考：kernel/timer.c和kernel/time/tick-common.c文件

##禁止抢占

内核是抢占性的，内核中的进程在任何时刻都可能停下来以便亮一个具有更高优先权的进程运行。这意味着一个任务与被抢占的任务可能会在同一临界区域内运行，为此内核抢占代码使用自旋锁作为非抢占区域的标记。如果一个自旋锁被持有，内核便不能进行抢占。
其实使用自旋锁已经可以防止内核抢占了，但是有时候仅仅需要禁止内核抢占，不需要像自旋锁那样连中断都屏蔽掉。

这时候就需要使用禁止内核抢占的方法了：
![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/10.7.PNG)

这里的preempt_disable()和preempt_enable()是可以嵌套调用的，disable和enable的次数最终应该是一样的。

禁止抢占的头文件参见：<linux/preempt.h>

##顺序和屏障

对于一段代码，编译器或者处理器在编译和执行时可能会对执行顺序进行一些优化，从而使得代码的执行顺序和我们写的代码有些区别。

一般情况下，这没有什么问题，但是在并发条件下，可能会出现取得的值与预期不一致的情况

比如下面的代码：
/\* 
 \* 线程A和线程B共享的变量 a和b
 \* 初始值 a=1, b=2
 \*/
int a = 1, b = 2;

/\*
 \* 假设线程A 中对 a和b的操作
 \*/
void Thread_A()
{
    a = 5;
    b = 4;
}

/\*
 \* 假设线程B 中对 a和b的操作
 \*/
void Thread_B()
{
    if (b == 4)
        printf("a = %d\n", a);
}
由于编译器或者处理器的优化，线程A中的赋值顺序可能是b先赋值后，a才被赋值。

所以如果线程A中 b=4; 执行完，a=5; 还没有执行的时候，线程B开始执行，那么线程B打印的是a的初始值1。

这就与我们预期的不一致了，我们预期的是a在b之前赋值，所以线程B要么不打印内容，如果打印的话，a的值应该是5。

在某些并发情况下，为了保证代码的执行顺序，引入了一系列屏障方法来阻止编译器和处理器的优化。

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/10.8.PNG)

为了使得上面的小例子能正确执行，用上表中的函数修改线程A的函数即可：

/\*
 \* 假设线程A 中对 a和b的操作
 \*/
void Thread_A()
{
    a = 5;
    mb(); 
    /\* 
     \* mb()保证在对b进行载入和存储值(值就是4)的操作之前
     \* mb()代码之前的所有载入和存储值的操作全部完成(即 a = 5;已经完成)
     \* 只要保证a的赋值在b的赋值之前进行，那么线程B的执行结果就和预期一样了
     \*/
    b = 4;
}
##总结

本节讨论了大约11种内核同步方法，除了大内核锁已经不再推荐使用之外，其他各种锁都有其适用的场景。

了解了各种同步方法的适用场景，才能正确的使用它们，使我们的代码在安全的保障下达到最优的性能。

同步的目的就是为了保障数据的安全，其实就是保障各个线程之间共享资源的安全，下面根据共享资源的情况来讨论一下10种同步方法的选择。

10种同步方法在图中分别用蓝色框标出。
![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/10.9.PNG)

