#中断处理

中断处理一般不是纯软件来实现的，需要硬件的支持。通过对中断的学习有助于更深入的了解系统的一些底层原理，特别是驱动程序的开发。

##中断

为了提高CPU和外围硬件(硬盘，键盘，鼠标等等)之间协同工作的性能，引入了中断的机制。

没有中断的话，CPU和外围设备之间协同工作可能只有轮询这个方法：CPU定期检查硬件状态，需要处理时就处理，否则就跳过。

当硬件忙碌的时候，CPU很可能会做许多无用功（每次轮询都是跳过不处理）。

中断机制是硬件在需要的时候向CPU发出信号，CPU暂时停止正在进行的工作，来处理硬件请求的一种机制。

狭义的中断是异步的，不需要时钟信号，相反，异常是同步的（常常称为同步中断）

中断一般分为异步中断(一般由硬件引起)和同步中断(一般由处理器本身引起)。

**异步中断**：CPU处理中断的时间过长，所以先将硬件复位，使硬件可以继续自己的工作，然后在适当时候处理中断请求中耗时的部分。

举个例子：网卡的工作原理
网卡收到数据包后，向CPU发出中断信号，请求处理接收到的数据包。CPU将收到的数据包拷贝到内存后，即通知网卡继续工作至于数据包拷贝至内存后的处理会在适当的时候进行
这样做避免了处理数据包时间过长导致网卡接收数据包速度变慢。

**同步中断**：CPU处理完中断请求的所有工作后才反馈硬件

举个例子：系统异常处理(比如运算中的除0操作)
1. 应用程序出现异常后，需要内核来处理
2. 内核调用相应的异常处理函数来处理异常
3. 处理完后终了应用程序或者给出message
 
同步中断应该处理能很快完成的一种中断。

上半部分与下半部分

Linux中的中断程序是不需要重入的。当一个给定的中断处理程序正在执行时，相应的中断线在所有处理器上都会被屏蔽掉，以防在同一个中断线上接收另一个新的中断。通常情况下，所有的其他中断都是打开的，所以这些不同的中断线上的其他中断都能被处理，但当前中断线总是被禁止的。由此可以看出，同一中断处理程序绝不会被同时调用以处理嵌套的中断。

##中断相关函数

实现一个中断，主要需要知道3个函数：
1. 注册中断的函数
2. 释放中断的函数
3. 中断处理程序的声明
###注册中断的函数
位置：<linux/interrupt.h>  include/linux/interrupt.h
/\*
 \* irg     - 表示要分配的中断号
 \* handler - 实际的中断处理程序
 \* flags   - 标志位，表示此中断的具有特性
 \* name    - 中断设备名称的ASCII 表示，这些会被/proc/irq和/proc/interrupts文件使用
 \* dev     - 用于共享中断线，多个中断程序共享一个中断线时(共用一个中断号)，依靠dev来区别各个中断程序
 \* 返回值：
 \* 执行成功：0
 \* 执行失败：非0
 \*/
int request_irq(unsigned int irq,
                irq_handler_t handler,
                unsigned long flags,
                const char* name,
                void *dev)



###释放中断的函数
定义比较简单：

void free_irq(unsigned int irq, void *dev)
如果不是共享中断线，则直接删除irq对应的中断线。

如果是共享中断线，则判断此中断处理程序是否中断线上的最后一个中断处理程序:
是最后一个中断处理程序 -> 删除中断线和中断处理程序
不是最后一个中断处理程序 -> 删除中断处理程序


###中断处理程序的声明
/\* 
 \* 中断处理程序的声明
 \* @irp  - 中断处理程序(即request_irq()中handler)关联的中断号
 \* @dev  - 与 request_irq()中的dev一样，表示一个设备的结构体
 \* 返回值：
 \* irqreturn_t -  执行成功：IRQ_HANDLED  执行失败：IRQ_NONE
 \*/
static irqreturn_t intr_handler(int, irq, void *dev)


**中断上下文**：当执行一个中断处理程序时，内核处于中断上下文。（进程上下文是一种内核所处的操作模式，内核代表进程执行，e.g.，执行系统调用或运行内核进程的时候。进程上下文可以睡眠，也可以调用调度程序）
中断上下文与进程无关，因为没有后备程序，中断上下文不能睡眠，不能从中断上下文中调用某些函数

##中断处理机制

中断处理的过程主要涉及3函数：

do_IRQ 与体系结构有关，对所接收的中断进行应答
handle_IRQ_event 调用中断线上所有中断处理
ret_from_intr 恢复寄存器，将内核恢复到中断前的状态
 

处理流程可以参见书中的图，如下：
![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/7.1.PNG)
![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/7.2.PNG)
![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/7.3.PNG)

##总结
中断过程所做的工作包括应答并重新设置硬件，从设备拷贝数据到内存以及反之，处理硬件请求，并发送新的硬件请求。

中断处理对处理时间的要求很高，如果一个中断要花费较长时间，那么中断处理一般分为2部分。

上半部只做一些必要的工作后，立即通知硬件继续自己的工作。

中断处理中耗时的部分，也就是下半部的工作，CPU会在适当的时候去完成。
























