#系统调用
 
系统调用就是用户程序和硬件设备之间的桥梁。系统调用在用户空间进程与硬件设备之间添加了一个中间层
1）用户程序通过系统调用来使用硬件，而不用关心具体的硬件设备，这样大大简化了用户程序的开发。
比如：用户程序通过write()系统调用就可以将数据写入文件，而不必关心文件是在磁盘上还是软盘上，或者其他存储上。

2）系统调用使得用户程序有更好的可移植性。
只要操作系统提供的系统调用接口相同，用户程序就可在不用修改的情况下，从一个系统迁移到另一个操作系统。

3）系统调用使得内核能更好的管理用户程序，增强了系统的稳定性与安全性。
因为系统调用是内核实现的，内核通过系统调用来控制开放什么功能及什么权限给用户程序。
这样可以避免用户程序不正确的使用硬件设备，从而破坏了其他程序。

4）系统调用有效的分离了用户程序和内核的开发。
用户程序只需关心系统调用API，通过这些API来开发自己的应用，不用关心API的具体实现。
内核则只要关心系统调用API的实现，而不必管它们是被如何调用的。

在Linux中，系统调用是用户空间访问内核的唯一手段，除了异常与陷入外，它们是内核唯一的合法入口。
![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/5.1.PNG)

##Linux上的系统调用实现原理
要想实现系统调用，主要实现以下几个方面：

通知内核调用一个哪个系统调用
用户程序把系统调用的参数传递给内核
用户程序获取内核返回的系统调用返回值
下面看看Linux是如何实现上面3个功能的。
1. 通知内核调用一个哪个系统调用
每个系统调用都有一个系统调用号，系统调用发生时，内核就是根据传入的系统调用号来知道是哪个系统调用的。
在x86架构中，用户空间将系统调用号是放在eax中的，系统调用处理程序通过eax取得系统调用号。
系统调用号定义在内核代码：arch/alpha/include/asm/unistd.h 中，可以看出linux的系统调用不是很多。

2. 用户程序把系统调用的参数传递给内核
系统调用的参数也是通过寄存器传给内核的，在x86系统上，系统调用的前5个参数放在ebx,ecx,edx,esi和edi中，如果参数多的话，还需要用个单独的寄存器存放指向所有参数在用户空间地址的指针。
一般的系统调用都是通过C库(最常用的是glibc库)来访问的，Linux内核提供一个从用户程序直接访问系统调用的方法。
参见内核代码：arch/cris/include/arch-v10/arch/unistd.h

3. 用户程序获取内核返回的系统调用返回值
获取系统调用的返回值也是通过寄存器，在x86系统上，返回值放在eax中。

内核在执行系统调用的时候处于进程上下文。current指针指向当前任务，引发系统调用的那个进程。
在进程上下中，内核可以休眠（系统调用阻塞或显示调用schedule()的时候），可以被抢占。
（中断处理程序不能休眠）



