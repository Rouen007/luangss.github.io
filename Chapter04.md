#进程调度

最大限度利用处理器时间
现在的操作系统都是多任务的，为了能让更多的任务能同时在系统上更好的运行，需要一个管理程序来管理计算机上同时运行的各个任务（也就是进程）。
##多任务
Linux提供了抢占式多任务模式，有调度程序决定什么时候停止一个进程的运行，以便其他进程能得到执行的机会。
时间片：进程被抢占之前能够运行的时间（预设）。

进程：I/O消耗型、处理器消耗型进程
I/O消耗型：仅仅运行一小段时间，e.g.交互性场合
处理器消耗型进程：多数时间用来执行代码
##调度
这个管理程序就是调度程序，它的功能说起来很简单：

决定哪些进程运行，哪些进程等待
决定每个进程运行多长时间
此外，为了获得更好的用户体验，运行中的进程还可以立即被其他更紧急的进程打断。

总之，调度是一个平衡的过程。一方面，它要保证各个运行的进程能够最大限度的使用CPU(即尽量少的切换进程，进程切换过多，CPU的时间会浪费在切换上)；另一方面，保证各个进程能公平的使用CPU(即防止一个进程长时间独占CPU的情况)。

##调度实现原理

前面说过，调度功能就是决定哪个进程运行以及进程运行多长时间。

决定哪个进程运行以及运行多长时间都和进程的优先级有关。为了确定一个进程到底能持续运行多长时间，调度中还引入了时间片的概念。
进程的优先级有2种度量方法，一种是nice值，一种是实时优先级。

nice值的范围是-20～+19，值越大优先级越低，也就是说nice值为-20的进程优先级最大。

实时优先级的范围是0～99，与nice值的定义相反，实时优先级是值越大优先级越高。

实时进程都是一些对响应时间要求比较高的进程，因此系统中有实时优先级高的进程处于运行队列的话，它们会抢占一般的进程的运行时间。
 
实时优先级高于nice值，在内核中，实时优先级的范围是 0～MAX_RT_PRIO-1 MAX_RT_PRIO的定义参见 include/linux/sched.h
一个进程不可能有2个优先级。一个进程有了实时优先级就没有Nice值，有了Nice值就没有实时优先级。

##时间片
有了优先级，可以决定谁先运行了。但是对于调度程序来说，并不是运行一次就结束了，还必须知道间隔多久进行下次调度。

**时间片**是一个数值，表示一个进程被抢占前能持续运行的时间。
也可以认为是进程在下次调度发生前运行的时间(除非进程主动放弃CPU，或者有实时进程来抢占CPU)。

时间片的大小设置并不简单，设大了，系统响应变慢(调度周期长)；设小了，进程频繁切换带来的处理器消耗。默认的时间片一般是10ms

##调度实现原理（基于优先级和时间片）
下面举个直观的例子来说明：

假设系统中只有3个进程ProcessA(NI=+10)，ProcessB(NI=0)，ProcessC(NI=-10)，NI表示进程的nice值，时间片=10ms

1)调度前，把进程优先级按一定的权重映射成时间片(这里假设优先级高一级相当于多5msCPU时间)。
假设ProcessA分配了一个时间片10ms，那么ProcessB的优先级比ProcessA高10(nice值越小优先级越高)，ProcessB应该分配10*5+10=60ms，以此类推，ProcessC分配20*5+10=110ms

2)开始调度时，优先调度分配CPU时间多的进程。由于ProcessA(10ms),ProcessB(60ms),ProcessC(110ms)。显然先调度ProcessC

3) 10ms(一个时间片)后，再次调度时，ProcessA(10ms),ProcessB(60ms),ProcessC(100ms)。ProcessC刚运行了10ms，所以变成100ms。此时仍然先调度ProcessC

4) 再调度4次后(4个时间片)，ProcessA(10ms),ProcessB(60ms),ProcessC(60ms)。此时ProcessB和ProcessC的CPU时间一样，这时得看ProcessB和ProcessC谁在CPU运行队列的前面，假设ProcessB在前面，则调度ProcessB

5) 10ms(一个时间片)后，ProcessA(10ms),ProcessB(50ms),ProcessC(60ms)。再次调度ProcessC

6) ProcessB和ProcessC交替运行，直至ProcessA(10ms),ProcessB(10ms),ProcessC(10ms)。
这时得看ProcessA，ProcessB，ProcessC谁在CPU运行队列的前面就先调度谁。这里假设调度ProcessA

7) 10ms(一个时间片)后，ProcessA(时间片用完后退出),ProcessB(10ms),ProcessC(10ms)。

8) 再过2个时间片，ProcessB和ProcessC也运行完退出。

这个例子很简单，主要是为了说明调度的原理，实际的调度算法虽然不会这么简单，但是基本的实现原理也是类似的：

1）确定每个进程能占用多少CPU时间(这里确定CPU时间的算法有很多，根据不同的需求会不一样)

2）占用CPU时间多的先运行

3）运行完后，扣除运行进程的CPU时间，再回到 1）

##Linux调度算法
Linux上的调度算法是不断发展的，在2.6.23内核以后，采用了**“完全公平调度算法”**，简称CFS。---针对普通进程的调度类。
CFS完全摒弃时间片，分配给进程一个处理器使用的比重。
CFS：允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行的进程，CFS在所有可运行进程的总数的基础上计算出一个进程应该运行多久。依赖NICE值分配使用权重（而不再是分配时间片）。
可运行任务的数量区域无穷，每个线程能获得的运行时间将趋于0。最小运行时间的约束--*最小粒度*

##Linux调度的实现
其实Linux上的调度器是以模块方式提供的，每个调度器有不同的优先级，所以可以同时存在多种调度算法。
每个进程可以选择自己的调度器，Linux调度时，首先按调度器的优先级选择一个调度器，再选择这个调度器下的进程。

时间记账、进程选择、调度器入口、睡眠与唤醒
虚拟实时：vruntime变量存放进程的虚拟运行时间：记录一个程序已经运行了多久，还需要运行多久。
当CFS需要选择下一个运行的进程的时候，会挑选具有最小vruntime值的进程（红黑树）


CFS算法在分配每个进程的CPU时间时，不是分配给它们一个绝对的CPU时间，而是根据进程的优先级分配给它们一个占用CPU时间的百分比。

比如ProcessA(NI=1)，ProcessB(NI=3)，ProcessC(NI=6)，在CFS算法中，分别占用CPU的百分比为：ProcessA(10%)，ProcessB(30%)，ProcessC(60%)

因为总共是100%，ProcessB的优先级是ProcessA的3倍，ProcessC的优先级是ProcessA的6倍。

Linux上的CFS算法主要有以下步骤：(还是以ProcessA(10%)，ProcessB(30%)，ProcessC(60%)为例)

1)计算每个进程的vruntime(注1)，通过update_curr()函数更新进程的vruntime。
2)选择具有最小vruntime的进程投入运行。（注2）
3)进程运行完后，更新进程的vruntime，转入步骤2) （注3）

注1. 这里的vruntime是进程虚拟运行的时间的总和。vruntime定义在：kernel/sched_fair.c 文件的 struct sched_entity 中。
注2. 这里有点不好理解，根据vruntime来选择要运行的进程，似乎和每个进程所占的CPU时间百分比没有关系了。
1）比如先运行ProcessC，(vr是vruntime的缩写)，则10ms后：ProcessA(vr=0)，ProcessB(vr=0)，ProcessC(vr=10)
2）那么下次调度只能运行ProcessA或者ProcessB。(因为会选择具有最小vruntime的进程)
长时间来看的话，ProcessA、ProcessB、ProcessC是公平的交替运行的，和优先级没有关系。
而实际上vruntime并不是实际的运行时间，它是实际运行时间进行加权运算后的结果。
比如上面3个进程中ProcessA(10%)只分配了CPU总的处理时间的10%，那么ProcessA运行10ms的话，它的vruntime会增加100ms。
以此类推，ProcessB运行10ms的话，它的vruntime会增加(100/3)ms,ProcessC运行10ms的话，它的vruntime会增加(100/6)ms。
实际的运行时，由于ProcessC的vruntime增加的最慢，所以它会获得最多的CPU处理时间。
上面的加权算法是我自己为了理解方便简化的，Linux对vruntime的加权方法还得去看源码^-^
注3.Linux为了能快速的找到具有最小vruntime，将所有的进程的存储在一个红黑树中。这样树的最左边的叶子节点就是具有最小vruntime的进程，新的进程加入或有旧的进程退出时都会更新这棵树。

调度器入口
睡眠和唤醒
睡眠（被阻塞）的进程处于一个特殊的不可执行的状态，等待某个事件的发生。
睡眠：从执行红黑树中移出，放入等待列表。
唤醒：从等待队列中移出到可执行红黑树中。

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/4.1.PNG)

##抢占和上下文切换
上下文切换：从一个可执行进程切换到另一个可执行进程。
用户抢占：发生在：从系统调用分会用户空间时；从中断处理程序返回用户空间时。
内核抢占：只要没有持有锁，内核就可以抢占。
内核的抢占发生在：中断处理程序正在执行，且返回内核空间之前；内核代码再一次具有可抢占性；内核显示地调用schedule()；内核有任务阻塞（调用schedule()）。

##实时调度策略
--SCHED_FIFO，SCHED_RR
SCHED_FIFO进程处于可执行状态时将一直执行下去知道受阻塞或显示地释放处理器。只有优先级更高的SCHED_FIFO，SCHED_RR能够抢占。不具有时间片。
SCHED_RR是带有时间片的SCHED_FIFO，SCHED_RR在耗尽事前分配给的时间片之后就无法继续执行了。是一种实时轮流的调度算法。SCHED_RR在耗尽时间片时，同一优先级的其他实时进程将被轮流调度

##调度相关的系统调用
调度相关的系统调用主要有2类：
1) 与调度策略和进程优先级相关 (就是上面的提到的各种参数，优先级，时间片等等) - 下表中的前8个
2) 与处理器相关 - 下表中的最后3个

![image](https://github.com/Rouen007/luangss.github.io/blob/master/image-lib/4.2.PNG)